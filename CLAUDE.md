# Terminal Calendar Project

## Project Overview
A terminal-based calendar application that displays an AI-generated daily schedule with real-time updates, task completion tracking, and end-of-day reporting.

## Core Functionality
1. **Schedule Ingestion**: Parse schedule data (JSON format) generated by LLM from user's daily task list
2. **Real-time Display**: Show current schedule in terminal with visual indicators for current task
3. **Persistence**: Save state so app can be closed/reopened and resume at correct time
4. **Task Completion**: Mark tasks as complete during the day
5. **End-of-Day Report**: Generate summary of completed vs. incomplete tasks

## Technology Stack
- **Language**: Python 3.11+
- **TUI Framework**: Textual (modern, reactive terminal UI framework)
- **Data Format**: JSON for schedule storage and state persistence
- **Datetime Handling**: Python datetime + dateutil
- **Data Validation**: Pydantic for schedule validation

## Architecture

### Components
1. **Schedule Parser** (`schedule_parser.py`)
   - Parse JSON schedule format
   - Validate schedule structure
   - Convert to internal data model

2. **Calendar App** (`calendar_app.py`)
   - Main Textual application
   - Real-time UI updates (every minute)
   - Display current/upcoming tasks
   - Handle user input for task completion

3. **State Manager** (`state_manager.py`)
   - Track task completion status
   - Persist state to disk
   - Load previous state on startup

4. **Report Generator** (`report_generator.py`)
   - Generate end-of-day summary
   - Save reports to `~/.terminal-calendar/reports/`

5. **CLI** (`cli.py`)
   - Entry point using Click or Typer
   - Commands: `load`, `view`, `complete`, `report`

### Data Models

**Schedule Format** (generated by LLM):
```json
{
  "date": "2026-02-13",
  "tasks": [
    {
      "id": "task_1",
      "title": "Morning standup",
      "start_time": "09:00",
      "end_time": "09:15",
      "description": "Daily team sync",
      "priority": "high"
    }
  ]
}
```

**State Format** (persisted):
```json
{
  "schedule_file": "schedule_2026-02-13.json",
  "completed_tasks": ["task_1", "task_3"],
  "last_updated": "2026-02-13T14:30:00"
}
```

## File Structure
```
terminal-calendar/
├── README.md
├── CLAUDE.md (this file)
├── IMPLEMENTATION.md
├── pyproject.toml
├── src/
│   └── terminal_calendar/
│       ├── __init__.py
│       ├── cli.py
│       ├── calendar_app.py
│       ├── schedule_parser.py
│       ├── state_manager.py
│       ├── report_generator.py
│       └── models.py
├── tests/
│   ├── test_schedule_parser.py
│   ├── test_state_manager.py
│   └── fixtures/
│       └── sample_schedule.json
└── examples/
    └── sample_schedule.json
```

## User Workflow
1. User prompts LLM with daily tasks
2. LLM generates schedule JSON file
3. User runs: `tcal load schedule.json`
4. User runs: `tcal view` to see calendar
5. During day: navigate and mark tasks complete with keyboard shortcuts
6. End of day: `tcal report` generates summary

## UI Design Principles
- **High Contrast**: Use bold colors for current task
- **Clear Time Indicators**: Show current time prominently
- **Status Icons**: ✓ for complete, ○ for pending, ► for current
- **Minimal Clutter**: Focus on what's happening now and next
- **Responsive**: Update every minute automatically

## Development Priorities
1. Core functionality first (display schedule, track time)
2. State persistence
3. Task completion
4. Polish UI
5. Add reports
6. Add nice-to-have features

## Commands Reference
- `tcal load <schedule.json>` - Load a new schedule
- `tcal view` - View current schedule (main TUI)
- `tcal complete <task_id>` - Mark task complete via CLI
- `tcal report` - Generate end-of-day report
- `tcal report --date YYYY-MM-DD` - Report for specific date

## Configuration
Config stored at: `~/.terminal-calendar/config.json`
- Theme preferences
- Report output directory
- Default schedule directory

## Notes for Agents
- Use type hints throughout
- Add docstrings to all public functions
- Write tests for core logic (parser, state manager)
- Keep UI code separate from business logic
- Use Pydantic models for data validation
- Follow PEP 8 style guidelines
